# Задачи

Необходимо реализовать функции для работы с бинарным деревом поиска:

    // Инициализация дерева
    void init(tree* t);
    
    // Удалить все элементы из дерева
    void clean(tree* t);
    
    // Поиск элемента по значению. Вернуть NULL если элемент не найден
    node* find(tree* t, int value);
    
    // Вставка значения в дерево:
    // 0 - вставка выполнена успешно
    // 1 - элемент существует
    // 2 - не удалось выделить память для нового элемента
    int insert(tree* t, int value);
    
    // Удалить элемент из дерева:
    // 0 - удаление прошло успешно
    // 1 - нет элемента с указанным значением
    int remove_node(tree* t, int value);
    
    // Удалить минимальный элемент из поддерева, корнем которого является n
    // Вернуть значение удаленного элемента
    int remove_min(node* n);
    
    // Выполнить правое вращение поддерева, корнем которого является n:
    // 0 - успешно выполненная операция
    // 1 - вращение невозможно 
    int rotate_right(node* n);
    
    // Выполнить левое вращение поддерева, корнем которого является n:
    // 0 - успешно выполненная операция
    // 1 - вращение невозможно
    int rotate_left(node* n);
    
    // Вывести все значения из поддерева, корнем которого является n
    // по уровням начиная с корня.
    // Каждый уровень выводится на своей строке. 
    // Элементы в строке разделяются пробелом. Если элемента нет, заменить на _. 
    // Если дерево пусто, вывести -
    void print(node* n);
    
    // Вывести все значения дерева t, аналогично функции print
    void print_tree(tree* t);

Используя функции реализовать программу, которая:

1. создает пустое дерево, считывает 4 элемента ai, |ai| <= 2147483647 и заносит их в дерево;
2. выводит дерево (используя функцию print_tree) и пустую строку;
3. считывает 3 элемента ai, |ai| <= 2147483647 и заносит их в дерево;
4. выводит дерево и пустую строку;
5. считывает m1, |m1| <= 2147483647 и ищет элемент с заданным значением в дереве;
выводит через пробел значение предка и потомков найденного элемента,
если нет значений предка или потомков вывести "_" вместо таких значений;
вывести "-", если элемент не найден; вывести пустую строку;
6. считывает m2, |m2| <= 2147483647 и ищет элемент с заданным значением в дереве;
выводит через пробел значение предка и потомков найденного элемента,
если нет значений предка или потомков вывести "_" вместо таких значений;
вывести "-", если элемент не найден; вывести пустую строку;
7. cчитывает m3, |m3| <= 2147483647 и удаляет из дерева элемент с заданным значением (если такой элемент есть);
8. выводит дерево и пустую строку;
9. выполняет левый поворот дерева относительно корня, пока это возможно;
10. выводит дерево и пустую строку;
11. выполняет правый поворот дерева относительно корня, пока это возможно;
12. выводит дерево и пустую строку;
13. выводит на экран количество элементов в дереве и пустую строку
14. очищает дерево
15. выводит дерево и пустую строку;

# Ход работы

Для бинарного дерева были взяты следующие структуры дерева и узлов:

    typedef struct tree { 
        int num; 
        struct node *head; 
    } tree;
    
    typedef struct node 
    {
        int value;
        struct node *left; 
        struct node *right; 
        struct node *parent;
    } node;

Инициализация пустого дерева представлена на языке С следующим образом:

    // Инициализация дерева
    void init(tree *t){
        t->head = NULL;
        t->num = 0;
    }

Очищать дерево нужно с крайних узлов. В следующем алгоритме очищение начинается с нижнего левого потомка: спуск по левому поддереву или по правому, пока это возможно. После нужно обновить указатель у родителя, а значит и узнать, каким потомком является удаляемый узел. Это будет продолжаться, пока не останется единственный корень, который будет удален по-другому, так как в этом случае нужно обновить данные дерева. Сама функция представлена далее:

    // Удалить все элементы из дерева
    void clean(tree *t)
    {
        while(t->num > 1) 
        {
            node *temp = t->head; 
            while(temp->left != NULL || temp->right != NULL)  //спуск
            {
                if(temp->left != NULL) 
                    temp = temp->left; 
                else
                    temp = temp->right; 
            }
            node *parent = temp->parent; 
            if(parent->left == temp) //определение, который из потомоков
                parent->left = NULL; 
            else
                parent->right = NULL; 
            free(temp); 
            t->num--; 
        }
        if(t->head != NULL) //удаление последнего корневого узла
        { 
            free(t->head); 
            t->head = NULL; 
            t->num = 0; 
        }
    }

Для поиска элемента по значению необходимо переходить от узла к его потомкам, пока искомое значение не равно значению узла, либо пока спуск не приведет к указателю на NULL. Спуск проделывается следующим образом: если необходимое значение больше значения текущего узла, то переходим к правому потомку, иначе к левому. 

Сама функция вернет указатель на узел, который будет равен NULL, если значение не найдено:

    // Поиск элемента по значению
    node* find(tree *t, int value)
    {
        node *temp = t->head; 
        while(temp != NULL && temp->value != value) 
        {
            if(value < temp->value) 
                temp = temp->left; 
            else
                temp = temp->right; 
        }
        return temp; 
    }

Вставить значение можно в пустое дерево (первый случай в алгоритме), но в ином случае придется спускаться по дереву, пока не найдем значение, которое уже существует, либо пока не найдем узел с указателем NULL. Спуск осуществляется следующим образом: если значение вставляемого узла больше текущего, то переходим к правому потомку, иначе к левому, но перед переход идет проверка, не является ли он NULL. В случае положительного ответа, будет вставлено значение, иначе произойдет обычный переход и повторения цикла.
Если значение уже существует, то цикл заканчивается, а функция возвращает единицу:

    // Вставка значения в дерево
    int insert(tree *t, int value)
    {
        if(t->head == NULL) //если дерево пустое
        {
            t->head = malloc(sizeof(node)); 
            t->head->parent = NULL; 
            t->head->left = NULL; 
            t->head->right = NULL; 
            t->head->value = value; 
            t->num++; 
            return 0; 
        }
    
        node *temp = t->head; 
        while(temp->value != value) //пока не найдем уже существующее значение
        {
            if(value > temp->value)
            {
                if(temp->right != NULL) //если узел существует
                {
                    temp = temp->right; 
                }
                else 
                {
                    temp->right = malloc(sizeof(node)); 
                    temp->right->value = value; 
                    temp->right->parent = temp;
                    temp->right->right = NULL; 
                    temp->right->left = NULL; 
                    t->num++; 
                    return 0; 
                }
            }
            else 
            {
                if(temp->left != NULL) //если узел существует
                {
                    temp = temp->left;
                }
                else 
                {
                    temp->left = malloc(sizeof(node)); 
                    temp->left->value = value; 
                    temp->left->parent = temp; 
                    temp->left->right = NULL; 
                    temp->left->left = NULL; 
                    t->num++; 
                    return 0; 
                }
            }
        }
        return 1; //значение уже существует
    }

При удалении элемента можно рассмотреть три случая: у удаляемого элемента нет потомков, есть только один или есть оба. В первом случае никаких проблем не возникнет, ведь нужно просто обновить указатель у родителя и очистить память. Во втором случае нужно понять, на какой элемент нужно поменять удаляемый (а значит обновить указатель именно на него), а после уже очищать память.

В третьем случае больше всего действий: изначально определяется самый правый элемент в левом поддереве, так как именно на него заменится удаляемый. В этом случае, необходимо предвидеть, что у самого правого элемента может быть левый потомок, который встанет на его место. Может быть еще один частный случай - если самый правый элемент и будет левым потомком удаляемого элемента, ведь в этом случае нужно будет переместить все это поддерево на один узел вверх:

    // Удалить элемент из дерева
    int remove_node(tree *t, int value)
    {
        node *temp = find(t, value); //находим элемент в дереве по значению
        if(temp == NULL) 
            return 1;
        if(temp->left == NULL && temp->right == NULL) //нет потомков
        {
            node *parent = temp->parent; 
            if(parent == NULL) 
                t->head = NULL; /
            else //иначе
            {
                if(parent->left == temp) 
                    parent->left = NULL; 
                else
                    parent->right = NULL; 
            }
            free(temp); 
            t->num--; 
            return 0;
        }
        else if(temp->right != NULL && temp->left == NULL) //если есть только правый потомок
        {
            node *parent = temp->parent; 
            if(parent == NULL)  
            {
                t->head = temp->right; 
                t->head->parent = NULL; 
            }
            else 
            {
                if(parent->left == temp) 
                    parent->left = temp->right; 
                else
                    parent->right = temp->right; 
            }
            temp->right->parent = parent; 
            free(temp); 
            t->num--; 
            return 0; 
        }
        else if(temp->right == NULL && temp->left != NULL) //если есть только левый потомок
        {
            node *parent = temp->parent; 
            if(parent == NULL) 
            {
                t->head = temp->left;
                t->head->parent = NULL; 
            }
            else 
            {
                if(parent->left == temp) 
                    parent->left = temp->left; 
                else
                    parent->right = temp->left; 
            }
            temp->left->parent = parent; 
            free(temp); 
            t->num--;
            return 0; 
        }
        else //если есть оба потомка
        {
            node *max = temp->left; 
            while(max->right != NULL) 
                max = max->right;
            if (max->parent == temp) 
                temp->left = max->left; 
            else
                max->parent->right = max->left; 
    
            node *parent = temp->parent; 
            if(parent == NULL) 
                t->head = max; 
            else
            {
                if(parent->left == temp) 
                    parent->left = max; 
                else
                    parent->right = max; 
            }
            max->parent = parent; 
            max->right = temp->right; 
            max->left = temp->left; 
            max->right->parent = max; 
            if(max->left != NULL) 
                max->left->parent = max; 
            free(temp);
            t->num--; 
            return 0; 
        }
    }

Поворот дерева будет разобран на примере правого поворота. Поворот невозможен, только если у поворачиваемого узла нет левого потомка (возрвщаем единицу). Дальше проверяется, является ли вращаемый элемент корнем дерева, ведь в этом случае будет обновляться указатель в дереве. После этого нужно запомнить правый элемент левого поддерева, ведь он станет левым элементов правого поддерева после вращения.

Далее происходит перемещение левого элемента с корнем, а вращаемый элемент станет правый потомком у нового корня. Данная функция реализована следующим образом.

    // Выполнить правое вращение поддерева, корнем которого является temp
    int rotate_right(tree *t, node *temp)
    {
        if(temp == NULL || temp-> left == NULL) //если элемент пустой или левого потомка нет
            return 1;
    
        node *rightofnew = temp->left->right; 
        node *parent = temp->parent; 
        if(parent == NULL) 
        {
            t->head = temp->left; 
            t->head->parent = NULL;  
            temp->parent = t->head; 
        }
        else 
        {
            if(parent->left == temp) 
                parent->left = temp->left; 
            else 
                parent->right = temp->left; 
            temp->left->parent = temp->parent; 
            temp->parent = parent; 
        }
        temp->left->right = temp; 
        temp->left = rightofnew;
        if(rightofnew != NULL)
            rightofnew->parent = temp; 
        return 0; 
    }

Чтобы выполнить вывод, который просят в данном задании, необходимо обойти дерево в ширину, для которой нужна очередь, которая была взята как двухсвязный список:

    // Двусвязный список
    typedef struct node_list { 
        node *value; 
        struct node_list *next; 
        struct node_list *prev; 
    } node_list;
    
    typedef struct list { 
        struct node_list *head; 
        struct node_list *tail; 
    } list;
    
    void init_list(list *l)
    {
        l->head = NULL;
        l->tail = NULL;
    }
    
    int push_front(list *l, node *value) //вставить в начало
    {
        node_list *temp = malloc(sizeof(node_list)); 
        temp->value = value; 
        temp->next = l->head; 
        temp->prev = NULL; 
        if (l->head)
            l->head->prev = temp;
        l->head = temp; 
        if (l->tail == NULL)
            l->tail = temp;
        return 0; 
    }
    
    int remove_last(list *l) 
    {
        node_list *temp = l->tail;
        if (temp == NULL) 
            return -1; 
        if (temp->prev != NULL) 
            temp->prev->next = NULL; 
        else 
            l->head = NULL; 
        l->tail = temp->prev; 
        if (temp->value != NULL)
        {
            printf("%d ", temp->value->value); 
            free(temp); 
        }
        else 
        {
            int numNULL = 0; 
            while (temp->value == NULL)
            { 
                numNULL++; 
                free(temp); 
                temp = l->tail; 
                if (temp == NULL || temp->value != NULL) 
                    break; 
                if (temp->prev != NULL) 
                    temp->prev->next = NULL; 
                else 
                    l->head = NULL; 
                l->tail = temp->prev; 
            }
            return numNULL; 
        }
        return 0; 
    }

При удалении элемента из списка будет возвращено количеству значений NULL, которые были встречены в конце очереди. Это потребуется для вывода пустых элементов как "\_", но и без лишнего вывода, когда вся строка равна "\_" (в случае, если дерево закончилось). 

Для вывода необходимо ввести счетчик элементов и максимальное количество элементов на текущем уровне, которые будут определять, когда необходимо переходить на новую строку. Также создается очередь, в которую заносится первый элемент. Цикл длится до тех пор, пока очередь не будет пустой. С каждым элементом в очереди будут проводиться следующие действия: добавление в очередь потомков текущего элемента, удаление текущего элемента из очереди, а также увеличение счетчика. В конце цикла идет проверка, которая и определяет, время ли переходить на новую строку.

Если текущий элемент, взятый из очереди пуст, то стоит удалить текущий элемент из очереди, а по окончанию этого действия будет выведено количество пустых элементов до следующего непустого. Если после этого действия список не пуст или количество подряд идущих пустых элементов не равно нулю, то происходит добавление новых значений NULL в очередь и вывод, но происходит, пока пустые элементы есть или же пока не придет время переходить на новую строку.

Если это второй вариант, то проходит условие, в котором происходит окончательный вывод пустых элементов, но только в том случае, если очередь не пуста (и ее следующий для вывода элемент не пуст). Также в этом условии обновляется счетчик, так как он уже перешел максимальное число элементов, которое и нужно отнять, чтобы знать, сколько было выведено элементов на этом новом уровне.

В самом конце функции выводится новая строка:

    // Вывести все значения из поддерева, корнем которого является n
    // по уровням начиная с корня.
    // Каждый уровень выводится на своей строке.
    // Элементы в строке разделяются пробелом. Если элемента нет, заменить на _.
    // Если дерево пусто, вывести -
    void print(node *n)
    {
        if (n == NULL) //если корень поддерева пустой
        {
            printf("-\n");
        }
        else 
        {
            int counter = 0; //счетчик выведенных элементов на уровне
            int max = 1; //максимум элементов на текущем уровне
            list *l = NULL; 
            l = malloc(sizeof(list)); 
            init_list(l); 
            push_front(l, n); 
            while (l->tail != NULL) //пока очередь не пуста
            {
                node *temp = l->tail->value; 
                if (temp != NULL) 
                {
                    push_front(l, temp->left); 
                    push_front(l, temp->right); 
                    remove_last(l); 
                    counter++; //увеличиваем счетчик на единицу
                }
                else //иначе
                {
                    int number = remove_last(l); 
                    if (counter != 0 || l->tail != NULL) //если счетчик не равен нулю или если очередь не пуста
                    {
                        for(int i = 0; i < number && i + counter < max; i++) 
                        {
                            push_front(l, NULL); 
                            push_front(l, NULL);
                            printf("_ "); 
                        }
                        if (l->tail != NULL && l->tail->value != NULL && number + counter > max) //если очередь не пуста, а пустые элементы были не все выведены
                        {
                            printf("\n"); 
                            for (int i = max; number + counter > i; i++)
                            {
                                push_front(l, NULL); 
                                push_front(l, NULL);
                                printf("_ "); 
                            }
                            counter -= max; //обновляем счетчик
                            max *= 2; 
                        }
                        counter += number;
                    }
                }
                if (counter >= max) //если вывели все элементы на уровне, то переходим на следующий
                {
                    max *= 2; 
                    counter = 0; 
                    printf("\n"); 
                }
            }
        }
        printf("\n"); //вывод пустой строки, как окончания вывода
    }

Вывод всего дерева представлен далее:

    // Вывести все значения дерева t
    void print_tree(tree *t)
    {
        print(t->head);
    }
    
Для вывода предка и потомков была создана отдельная функция, в которой находится элемент по значению, а дальше происходит вывод:

    //Вывод предка и потомков
    void print_about(tree *t, int value)
    {
        node *n = find(t, value); 
        if(n == NULL) 
            printf("-\n\n"); 
        else 
        {
            if(n->parent != NULL)
                printf("%d ", n->parent->value); 
            else 
                printf("_ "); 
    
            if(n->left != NULL)
                printf("%d ", n->left->value);
            else 
                printf("_ "); 
    
            if(n->right != NULL) 
                printf("%d\n\n", n->right->value); 
            else 
                printf("_\n\n"); 
        }
    }

Основная функция main в программе представлена дальше:

    int main() {
        //1
        int a[4];
        scanf("%d %d %d %d", &a[0], &a[1], &a[2], &a[3]); //ввод чисел, которые будут добавлены в дерево
    
        tree *t = NULL;
        t = malloc(sizeof(tree)); //выделение памяти для дерева
        init(t); //инициализация дерева
        for(int i = 0; i < 4; i++)
            insert(t, a[i]); //добавление элементов в дерево
        //2
        print_tree(t); //вывод дерева
        //3
        scanf("%d %d %d", &a[0], &a[1], &a[2]); //ввод элементов, которые будут добавлены в дерево
        for(int i = 0; i < 3; i++)
            insert(t, a[i]); //добавление элементов в дерево
        //4
        print_tree(t); //вывод дерева
        //5
        int m;
        scanf("%d", &m); //ввод числа, у которого будут проверяться предок и потомки
        print_about(t, m); //вывод значений предка и потомков у элемента со значением m
        //6
        scanf("%d", &m); //ввод числа, у которого будут проверяться предок и потомки
        print_about(t, m); //вывод значений предка и потомков у элемента со значением m
        //7
        scanf("%d", &m); //ввод числа, у которого будут проверяться предок и потомки
        remove_node(t, m); //вывод значений предка и потомков у элемента со значением m
        //8
        print_tree(t); //вывод дерева
        //9
        while(rotate_left(t, t->head) != 1); //пока возможно, дерево будет поворачиваться влево
        //10
        print_tree(t); //вывод дерева
        //11
        while(rotate_right(t, t->head) != 1); //пока возможно, дерево будет поворачиваться вправо
        //12
        print_tree(t); //вывод дерева
        //13
        printf("%d\n\n", t->num); //вывод числа элементов в дереве
        //14
        clean(t); //очистка дерева
        //15
        print_tree(t); //вывод пустого дерева
        return 0;
    }
    
Результат работы программы с данными из примера показывает то, что и ожидалось увидеть (рисунки 1 и 2).

![result](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr5/pictures/result%201.png)


Рисунок 1 - Результат работы программы, первая половина

![result](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr5/pictures/result%202.png)


Рисунок 2 - Результат работы программы, вторая половина

Успешные результаты тестов pipeline представлены на рисунке 3.

![tests](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr5/pictures/tests.png)


Рисунок 3 - Пройденные тесты pipeline

# Заключение

В процессе данной работы были выполнены все заданные задачи, реализованы функции для бинарного дерева, создана программа, выполняющая все функции.
