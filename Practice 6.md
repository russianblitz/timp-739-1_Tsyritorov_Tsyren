# Задачи

1. Реализовать обход дерева в ширину:
 - считать с входного потока 7 чисел и занести их в дерево;
 - вывести все значения вершин дерева через пробел в порядке их посещения.

 
2. Реализовать прямой обход дерева (использование рекурсии недопускается):
 - считать с входного потока 7 чисел и занести их в дерево;
 - вывести все значения вершин дерева через пробел в порядке их посещения.


3. Реализовать обратный обход дерева (использование рекурсии обязательно):
 - считать с входного потока 7 чисел и занести их в дерево;
 - вывести все значения вершин дерева через пробел в порядке их посещения.
И в отчете должна быть теория по реализованным обходам дерева с картинками.

# Ход работы

В данной работе используются программы из прошлых работ: бинарные деревья, как объект обхода, а также двухсвязные списки, как контейнер для хранения узлов.

Блок-схема обхода в ширину представлена на рисунке 1.

![picture1](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/picture1.png)


Рисунок 1 - Блок-схема обхода в ширину

В нем необходимо обходить дерево в порядке слева направо при спуске вниз по уровням. Для этого используется очередь в качестве контейнера. При обходе узла он выводится в консоль, а его потомки (сначала левый, а потом правый) заносятся в очередь. Таким образом, пока не будут пройдены все узлы одного уровня, то других уровней не будут выведены. Внутри цикла это и происходит до тех пор, пока очередь не станет пустой.

Реализация обхода в ширину приведена далее:

    void width(tree *t) //Вывод обходом в ширину с помощью очереди
    {
        list *l = NULL; //создаю очередь
        l = (list*)malloc(sizeof(list)); //выделяю память очереди
        init_list(l); //инициализирую
        push_front(l, t->head); //вставляю в очередь первый элемент
        while (l->tail != NULL){ //пока очередь не пуста
            node_list* temp = pop_last(l); //забираем последний элемент в очереди
            if(temp->value->left != NULL) //если слева есть потомок
                push_front(l, temp->value->left); //то вносим его в очередь
            if (temp->value->right != NULL) //если справа есть потомок
                push_front(l, temp->value->right); //то вносим его в очередь
            printf("%d ", temp->value->value); //вывод данного узла дерева
            free(temp); //очистка памяти от записи списка
        }
    }


Блок-схема прямого обхода представлена на рисунке 2.

![picture2](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/picture2.png)


Рисунок 2 - Блок-схема прямого обхода

В нем необходимо обходить дерево в порядке корень - левое поддерево - правое поддерево. Это необходимо сделать с использование контейнера, а поэтому будет использован стек. При обходе узла он будет сначала выведен, а после будет занесен сначала правый потомок, а потом левый (можно не заносить, а просто переходить к левому, как сделано в коде). Таким образом, из стека всегда будет вытаскиваться левый корень в первую очередь, а после уже правый, что и требуется.

Реализация прямого обхода приведена далее:

    void pre_order(tree *t) //Вывод прямым обходом с помощью стека
    {
        list *l = NULL; //создаю стек
        l = (list*)malloc(sizeof(list)); //выделяю память стеку
        init_list(l); //инициализирую
        node *temp; //создаем хранилище текущего узла дерева
        push_front(l, t->head); //вставляем корень дерева в стек
        while(l->head != NULL) //пока список не пуст
        {
            node_list* temp_list = pop_first(l); //забираем первое значение в списке
            temp = temp_list->value; //сохраняем узел от него
            free(temp_list); //очищаем память от записи списка
            while(temp != NULL) //пока текущий узел не будет пуст
            {
                printf("%d ", temp->value); //выводим значение узла
                if(temp->right) //если есть правый потомок
                    push_front(l, temp->right); //то вставляем его в стек
                temp = temp->left;  //переходим в левому потомку
            }
        }
    }

Блок-схема обратного обхода представлена на рисунке 3.

![picture3](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/picture3.png)


Рисунок 3 - Блок-схема обратного обхода

В нем необходимо обходить дерево в порядке левое поддерево - правое поддерево - корень. Необходимо реализовать функция рекурсивно, а поэтому изначально от узла поступающего на функцию будут сначала выполнены рекурсивные вызовы левого, а потом и правого потомком, а после уже будет выведен в консоль данный узел. Пока не будет закончено с левым поддеревом, к правому алгоритм не приступит. Рекурсивный вызов будет продолжаться, пока в качестве параметра не будет выдан пустой узел.

Реализация обратного обхода приведена далее:

    void post_order(node *temp) //Вывод обратным обходом с помощью рекурсии
    {
        if(temp == NULL) //если этого элемента не существует
            return;
        post_order(temp->left); //запускаем рекурсию для левого поддерева
        post_order(temp->right); //запускаем рекурсию для правого поддерева
        printf("%d ", temp->value); //выводим значение текущего элемента
    }
    
Результат работы программы с данными из примера показывает то, что и ожидалось увидеть (рисунки 4, 5 и 6).

![result1](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/result1.png)


Рисунок 4 - Результат работы программы, обход в ширину

![result2](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/result2.png)


Рисунок 5 - Результат работы программы, прямой обход

![result3](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/result3.png)


Рисунок 6 - Результат работы программы, обратный

Успешные результаты тестов pipeline представлены на рисунке 7.

![tests](https://gitlab.com/Russian_Blitz/practices/-/raw/master/pr6/pictures/tests.png)


Рисунок 7 - Пройденные тесты pipeline

# Заключение

В процессе данной работы были выполнены все заданные задачи, реализованы обходы бинарного дерева, созданы программы, выполняющие обходы.
